````markdown
# В предыдущих уроках мы говорили о том как создавать элементы в React без `JSX`.

```js
// Сперва нам нужно создать root, чтобы React мог делать манипуляции с DOM (рендерить DOM).
const root = ReactDOM.createRoot(document.getElementById("root"));

// создание элемента в чистом React без JSX.
const heading = React.createElement("h1", { id: "heading" }, "Hello World!");

// Таким образом h1 станет дочерним элементом этого div id="root"
root.render(heading);
```
````

Таким образом создаются элементы в чистом React без JSX.
При создании элемента мы передаем:

1. Тип элемента это `"h1"`
2. Атрибут для элемента `{ id: "heading" }`
3. Это то что мы хотим поместить внутрь элемента `"Hello World!"`

Таким образом при создании элемента в React, создается не тег в JS,
а обычный объект в чистом JavaScript.

```js
console.log(heading);

// Мы увидим объект
{
  $$typeof: Symbol(react.element),
  type: 'h1',
  key: null,
  ref: null,
  props: {id: 'heading', children: 'Hello World!'},
  _owner: null,
  [[Prototype]]: Object
}
```

Таким образом мы видим что, `"Hello World!"` который мы поместили внутрь тега `"h1"`,
это дочерний элемент `props: {id: 'heading', children: 'Hello World!'}`.

Когда мы вызываем `root.render(heading)`,  
мы передаём в этот React-объект идентификатор `div#root` — JavaScript-объект.  
Эта функция `render(heading)` берёт этот JavaScript-объект,  
создаёт тег `h1`, который понимает браузер, и помещает его внутрь тега `div#root`.  
Этот метод `render()` преобразует JavaScript-объект в тег `h1` и помещает его в DOM.
То есть становиться `HTML-элементом`.

Мы знаем что вообще не удобно создавать элементы в чистом React,
тем более когда есть вложенные дочерние элементы.
Поэтому в React есть `JSX`.

## Что такое `JSX`?

Это синтаксис JavaScript, который упрощает создания элемента в React.
Многие разработчики думают `JSX` это часть React.
Нет!
`React` - это другое.
`JSX` - это другое.
В `JSX` разработчики объединяют `HTML` и `JavaScript` вместе.

Как мы можем создать тег `h1` с помощью `JSX`?

```js
const jsxHeading = <h1>Hello World from JSX!</h1>;
```

Теперь появляется такой вопрос:
Написали ли мы в этом коде `HTML` внутри `JavaScript`?
Нет!
`JSX` - это не `HTML` внутри `JavaScript`!
`JSX` - это не `HTML`, это синтаксис похожий на `HTML`.

Когда выполняется этот фрагмент кода в `JSX` `<h1>Hello World from JSX!</h1>`,
он становится элементом React.
`JSX` - это элемент React?
Нет!
`JSX` - это просто синтаксис.
Элемент React это обычный `JavaScript` объект.

Как мы можем добавить атрибут в синтаксисе `JSX`?
Вот так:

```js
const jsxHeading = <h1 id="heading">Hello World from JSX!</h1>;
```

`JSX` - это не чистый `JavaScript`.
Движок в браузере не понимает `JSX`.
Почему?
Потому что движок `JavaScript` понимает `ECMAScript`.
Если движок `JavaScript` не понимает `JSX`, как тогда он работает?
Сборщики делают свою работу под капотом.
Еще до того как этот код `JSX` попадет в браузер в движок `JavaScript`,
он транслируется прежде чем попасть в движок `JavaScript`,
что значит транслируется?
Это означает что код `JSX` преобразуется в код понятным браузерам понятным `React`.
Мы же помещаем код `JSX` в функцию `render()` вот так:

```js
root.render(jsxHeading);
// или
root.render(<h1 id="heading">Hello World from JSX!</h1>);
```

Таким образом `React` понимает этот код?
Нет!
Поэтому этот код преобразуется до того как он попадет туда.

Кто этот код преобразует?
Преобразование выполняется с помощью сборщика например `Parcel`.
То есть `Parcel` сам это делает?
Нет!
`Parcel` - это как бы ваш менеджер, у него есть свои помощники.
`Parcel` передает ответственность за преобразование кода пакету,
который называется `babel`.
`babel` - быстро преобразует этот `JSX` код, в код понятный `React`.

## Как это все происходит?

Мы писали `React` код для создания элемента без `JSX`.
Созданный `React` элемент был преобразован в `JavaScript` объект.
Затем этот `JavaScript` объект превращается в `HTML-элемент`.
Вот так работает код на чистом `React` без `JSX`.
`React.createElement => ReactElement-JS Object => HTMLElement(render)`

А как тогда работает `JSX` код?
Когда мы пишем код `JSX` он преобразуется в `React` код, вот так:
`JSX => React.createElement => ReactElement-JS Object => HTMLElement(render)`

Вот так работает код `JSX`!
В конечном счете `JSX` превращается в обычный `React-элемент`.

Всю эту работу делает `Babel`!
`Babel` преобразует `JSX` в `ReactElement` далее сам `React` делает так
чтобы этот ReactElement был понятен браузеру,
то есть `React` преобразует `ReactElement` в `ReactElement-JS Object => HTMLElement(render)`.

`Babel` — это компилятор `JavaScript`.
Также `Babel` преобразует код более новой версии `JavaScript` на старую версию кода `JavaScript`.
Потому что старые браузеры не обновленные они не понимают новые версии `JavaScript` например `ES6` (`ECMAScript`).

Теперь мы знаем как работает `JSX`.
А как мы пишем атрибут `class` для `JSX`?
Обычно мы пишем в HTML-странице `class` вот так:

```html
<div id="root" class="root">
  <h1></h1>
</div>
```

Но в `JSX` мы пишем атрибут `class` вот так:

```js
// Если мы хотим указать атрибуты в `JSX` мы пишем их в стиле `camelCase`.
const jsxHeading = (
  <h1 id="heading" className="head">
    Hello World from JSX!
  </h1>
);

// Когда у нас добавляется вторая строка в JSX, мы добавляем круглые скобки (),
// как в примере выше.
```

Мы еще должны знать, когда мы присваиваем `JSX` код для наших переменных как в примерах выше,
то переменная содержит внутри себя `ReactElement`.
А как он туда попадает, мы уже выяснили выше о супергерое `Babel`.

## Теперь о самом главном в `React`.

А именно компоненты в `React`.
Что такое компонент?
В `React` все является компонентом.
Если мы посмотрим на веб-страницу, то кнопка будет компонентом, заголовок будет компонентом и т.д.

В `React` есть два типа компонента:

1. Компоненты на основе классов.
2. Функциональные компоненты.

## Что такое функциональный компонент в `React`?

Это обычная функция `JavaScript`, который возвращает код `JSX`,
в конце концов который возвращает элемент `React`.
При создании функционального компонента, названия функции должно быть с заглавной буквы.

```js
const HeadingComponent = () => {
  return <h1>Hello World! Functional Component</h1>;
};

// или

const HeadingComponent2 = () => <h1>Hello World! Functional Component</h1>;

// или когда добавляется больше одной строки

const HeadingComponent3 = () => (
  <div id="container">
    <h1>Hello World! Functional Component</h1>
  </div>
);
```

```js
// Обычная переменная с кодом JSX, который содержит элемент React в конце концов обычный JavaScript-объект
const heading = (
  <h1 id="heading" className="head">
    Hello World from JSX!
  </h1>
);

// Превращаем в функциональный компонент, который возвращает элемент React в конце концов обычный JavaScript-объект
const Heading = () => (
  <h1 id="heading" className="head">
    Hello World from JSX!
  </h1>
);
```

Мы же знаем чтобы `React` работал, мы должны создать корень в `React` с помощью тега `div id="root"`,
и мы добавляли туда переменную с `JSX` кодом или добавляли переменную который создавали с чистым `React` без `JSX`.
Вот так:

```js
// Сперва нам нужно создать root, чтобы React мог делать манипуляции с DOM (рендерить DOM).
const root = ReactDOM.createRoot(document.getElementById("root"));

// создание элемента в чистом React без JSX.
const heading = React.createElement("h1", { id: "heading" }, "Hello World!");

// создание элемента с помощью JSX
const heading = (
  <h1 id="heading" className="head">
    Hello World from JSX!
  </h1>
);

// Таким образом h1 станет дочерним элементом этого div id="root"
root.render(heading);
```

Так вот, как нам добавить функциональный компонент в корень `React`, то есть в функцию `root.render()`?
Можем ли мы отобразить данный функциональный компонент вот так?

```js
const HeadingComponent = () => {
  return <h1>Hello World! Functional Component</h1>;
};

root.render(HeadingComponent);
```

Нет! Не можем!
Потому что так мы отображаем обычный `ReactElement`.
Это не элемент `React` это функциональный компонент.
Мы отображаем функциональный компонент вот так:

```js
const HeadingComponent = () => {
  return <h1>Hello World! Functional Component</h1>;
};

root.render(<HeadingComponent />);
```

Вот так мы отображаем функциональный компонент на страницу.
Этот синтаксис который понимает супергерой `Babel`.

Если мы хотим чтобы один функциональный компонент отображался
внутри другого функционального компонента, мы пишем вот так:

```js
const Heading = () => (
  <div id="heading" className="head">
    Hello Murad!
  </div>
);

const HeadingComponent = () => {
  return (
    <div>
      <h1>Hello World! Functional Component</h1>
      <Heading />
    </div>
  );
};

// или вот так
const HeadingComponent = () => {
  return (
    <div>
      <h1>Hello World! Functional Component</h1>
      <Heading></Heading>
    </div>
  );
};

// Таким образом это <Heading/> будет заменен на это
const HeadingComponent = () => {
  return (
    <div>
      <h1>Hello World! Functional Component</h1>
      <div id="heading" className="head">
        Hello Murad!
      </div>
    </div>
  );
};

root.render(<HeadingComponent />);
```

Браузер не понимает что у нас есть функциональный компонент, или `JSX` код.
`Babel` преобразует все в обычный код `React`, то есть в `ReactElement`.
А `React` отображает то что понимает браузер, то есть обычный `JavaScript-объект` далее в `HTML-элемент`.

`Компонентная композиция (Component Composition)` - это объединение двух функциональных компонентов,
то есть отображение одного функционального компонента внутри другого функционального компонента.

## Добавление `JavaScript` выражения в `JSX`.

Например:

```js
const number = 1000;

// Добавление JavaScript выражения в функциональный компонент
const Heading = () => (
  <div id="heading" className="head">
    {number}
    Hello Murad!
  </div>
);

// создание ReactElement с помощью JSX
// Добавление JavaScript выражения в обычный JSX код
const heading2 = (
  <h1 id="heading" className="head">
    {number}
    Hello World from JSX!
  </h1>
);

// `JavaScript` выражения {number} => 1000 будет отображаться на HTML-странице.
```

Мы уже знаем как добавлять функциональный компонент внутри другого функционального компонента.
Теперь как нам добавить обычный `ReactElement` или с помощью `JSX` созданный `ReactElement`,
то есть переменная который содержит `ReactElement`, внутри функционального компонента?

```js
// создание элемента в чистом React без JSX.
const heading1 = React.createElement("h1", { id: "heading" }, "Hello World!");

// создание элемента с помощью JSX
const heading2 = (
  <h1 id="heading" className="head">
    Hello World from JSX!
  </h1>
);

// Добавление ReactElement в функциональный компонент
const Heading = () => (
  <div id="heading" className="head">
    {heading1}
    {heading2}
    Hello Murad!
  </div>
);

// Так как это обычная переменная JavaScript которая возвращает значения
// мы можем добавлять это выражения внутри фигурных скобок {heading1} {heading2}.
```

Также `JSX` защищает наш веб-сайт от вредоносных данных.
Допустим мы получаем какие то вредоносные данные от какого `API`,
эти данные `JSX` не пропустит на наш веб-сайт, то есть `JSX` не будет слепо их выполнять.
`JSX` - предотвращает межсайтовый скриптинг.
Например:

```js
// вредоносные данные из api
const data = api.getData;

// Добавление JavaScript выражения в функциональный компонент
const Heading = () => (
  <div id="heading" className="head">
    {data}
    Hello Murad!
  </div>
);

// Эти вредоносные данные JSX не пропустит в наш веб-сайт.
// JSX очищает данные и затем только передает не вредоносные данные в наш веб-сайт.
```

Такой вопрос:
Если мы можем писать `JavaScript` выражения в `JSX` коде,
можем ли мы вызвать функциональный компонент внутри `JSX` кода?
В конце концов функциональный компонент это обычная функция `JavaScript`,
которая возвращает выражения а именно `ReactElement`.
Можем ли мы вызвать функциональный компонент как обычная функция JavaScript?
Вот так:

```js
const Heading = () => (
  <div id="heading" className="head">
    Hello Murad!
  </div>
);

const HeadingComponent = () => {
  return (
    <div>
      <h1>Hello World! Functional Component</h1>
      {Heading()} // вот так
    </div>
  );
};
```

Да мы можем, вызвать функциональный компонент как обычная функция `JavaScript`!
Функциональный компонент мы можем вызвать тремя разными способами:

```js
1 - <Heading />;
2 - <Heading></Heading>;
3 - {Heading()}
```

```

```
